#+AUTHOR: Andrea Giacomo Baldan 579117
#+EMAIL: a.g.baldan@gmail.com
#+TITLE: GROOVECLAM
#+LaTeX_HEADER: \usepackage{titlesec}
#+LaTeX_HEADER: \titleformat{\section}{\normalfont\Large\bfseries}{\thesection}{1em}{}[{\titlerule[0.8pt]}]
#+LaTeX_HEADER: \usepackage[T1]{fontenc} 
#+LaTeX_HEADER: \usepackage{libertine}
#+LaTeX_HEADER: \renewcommand*\oldstylenums[1]{{\fontfamily{fxlj}\selectfont #1}}
#+LaTeX_HEADER: \usepackage{lmodern}
#+LaTeX_HEADER: \lstset{basicstyle=\normalfont\ttfamily\small,numberstyle=\small,breaklines=true,frame=tb,tabsize=1,showstringspaces=false,numbers=left,commentstyle=\color{grey},keywordstyle=\color{black}\bfseries,stringstyle=\color{red}}
#+LaTeX_HEADER: \newenvironment{changemargin}[2]{\list{}{\rightmargin#2\leftmargin#1\parsep=0pt\topsep=0pt\partopsep=0pt}\item[]}{\endlist}
#+LaTeX_HEADER: \newenvironment{indentmore}{\begin{changemargin}{1cm}{0cm}}{\end{changemargin}}
#+BEGIN_ABSTRACT
A seguito degli eventi riguardanti il caso 'Napster' nei primi anni 2000,
l'industria musicale e la distribuzione del materiale digitale ha subito
notevoli cambiamenti e negli anni successivi prese piede il fenomeno del
P2P (scambio tra utenti di files musicali, e non solo, mediante la rete)
avviato da 'Napster', seguito da piattaforme e siti che offrono un servizio
di streaming di file audio/video nel (quasi) totale rispetto dei diritti
sugli album pubblicati. Grooveclam è una piattaforma online sulla linea del
recente defunto Grooveshark, un sito di streaming audio, che si
propone di offrire un servizio di condivisione musicale tra utenti,
permettendo di selezionare brani MP3 per l'ascolto, organizzarli in
playlist che possono essere condivise tra utenti connessi tra di loro o in 
semplici code di riproduzione anonime. Offre in più la possibilità di generare
e popolare la propria collezione personale di brani.
#+END_ABSTRACT
* Analisi Dei Requisiti
Si vuole realizzare una base di dati per la gestione di una libreria musicale
condivisa e la relativa interfaccia web che permetta interazione tra gli
utenti.\\
Il cuore della libreria è formato da un insieme di album, ogni album è 
identificato da un codice. E' inoltre formato da alcuni metadati (titolo, autore, 
anno di pubblicazione), è specificato se si tratta di un album registrato in 
studio o una versione live e, in quest'ultimo caso, è possibile specificare la 
città in cui si è svolta la registrazione del concerto, può possedere inoltre 
informazioni opzionali di carattere generale (critiche ricevute, recensioni o 
breve storia sulla realizzazione dell'album). Infine ogni album può avere una 
copertina, a cui fanno riferimento anche tutti i brani che contiene.\\ 
Un album contiene più brani musicali. Ogni brano contenuto nell'album è
identificato da un codice, ed è formato da alcuni metadati quali titolo,
genere, durata.\\
Degli utenti che possono accedere alla libreria, interessano l'indirizzo e-mail
e i dati anagrafici quali nome e cognome (opzionali). Ogni utente possiede una 
login, formata da username e password.\\
Gli utenti possono decidere di seguire altri utenti, eccetto se stessi. 
Ogni utente ha la possibilità di creare una propria collezione di brani 
preferiti selezionandoli tra quelli disponibili nella libreria, può creare una coda
di riproduzione anonima, o creare delle playlist delle quali interessa sapere il nome. 
Interessa inoltre sapere se si tratta di playlist pubbliche o private.\\
All'interno della collezione i brani non possono ripetersi mentre nelle code di
riproduzione o nelle playlist uno stesso brano può comparire più volte.
All'atto di registrazione un utente può decidere se attivare un abbonamento
free o utilizzare un piano premium.
* Progettazione concettuale
** Classi
- *Utenti:* Rappresenta un utente del servizio.
  - IdUtente: /Int/ =<<PK>>=
  - Nome: /String/
  - Cognome: /String/
  - Email: /String/
- *Login:* Rappresenta delle credenziali d'accesso per un utente.
  - Username: /String/ =<<PK>>=
  - Password: /String/
- *Iscrizioni:* Modella un piano di iscrizione.
  - Tipo: /Enum/ ['Free', 'Premium']
- *Brani:* Rappresenta un brano.
  - IdBrano: /Int/ =<<PK>>=
  - Titolo: /String/
  - Genere: /String/
  - Durata: /Float/
- *Album:* Modella un album di brani.
  - IdAlbum: /Int/ =<<PK>>=
  - Titolo: /String/
  - Autore: /String/
  - Info: /String/
  - Anno: /Date/
  Sono definite le seguenti sottoclassi disgiunte con vincolo di partizionamento.
  - *Live:* Rappresenta un album registrato durante una performance live.
    - Locazione: /String/
  - *Studio:* Rappresenta un album registrato in studio.
- *Playlist:* Modella una playlist.
  - Nome: /String/
  Sono definite le seguenti sottoclassi disgiunte con vincolo di partizionamento.
  - *Pubblica:* Rappresenta una playlist pubblica, a cui tutti gli utenti possono accedere all'ascolto.
  - *Privata:* Rappresenta una playlist privata, solo il creatore può accedervi all'ascolto
- *Collezioni:* Rappresenta una collezione di brani preferiti dall'utente.
  - IdCollezione: /Int/ =<<PK>>=
** Associazioni
- *Utenti-Login:* "Posside"
  - Ogni utente possiede una login, ogni login e' posseduta da un utente.
  - Molteplicità 1 : 1
  - Totale verso *Utenti*, totale verso *Login*.
- *Utenti-Collezioni:* "Crea"
  - Ogni utente può creare zero o una collezione, ogni collezione può essere creata da un solo utente.
  - Molteplicità 1 : 1
  - Parziale verso *Utenti*, totale verso *Collezioni*.
- *Utenti-Brani:* "Ascolta"
  - Ogni utente può ascoltare zero o più brani, ogni brano può essere ascoltato da zero o più utenti.
  - Molteplicità N : N
  - Parziale verso *Utenti*, parziale verso *Brani*.
  - Attributi:
    - Timestamp: /Timestamp/
- *Utenti-Brani:* "Accoda"
  - Ogni utente può accodare zero o più brani, ogni brano può essere accodato da zero o più utenti.
  - Molteplicità N : N
  - Parziale verso *Utenti*, parziale verso *Brani*.
  - Attributi:
    - Timestamp: /Timestamp/
- *Utenti-Utenti:* "Segue"
  - Ogni utente può seguire zero o più utenti, ogni utente può essere seguito da zero o più utenti.
  - Molteplicità N : N
  - Parziale verso entrambi.
- *Utenti-Playlist*: "Crea"
  - Ogni utente può creare zero o più playlist, ogni playlist può essere creata da un solo utente.
  - Molteplicità N : 1
  - Parziale verso *Utenti*, totale verso *Playlist*.
- *Utenti-Iscrizioni:* "Iscritto"
  - Ogni utente può avere una sola iscrizione, ogni iscrizione può essere associata ad un solo utente.
  - Molteplicità 1 : 1
  - Totale verso *Utenti* e verso *Iscrizioni*.
- *Playlist-Brani:* "PopolataDa"
  - Ogni playlist è popolata da zero o più brani, ogni brano popola zero o più playlist.
  - Molteplicità N : N
  - Parziale verso *Playlist*, parziale verso *Brani*.
- *Brani-Album:* "AppartieneA"
  - Ogni brano appartiene a zero o un brano, ogni brano contiene uno o più brani.
  - Molteplicità 1 : N
  - Parziale verso *Brani*, totale verso *Album*.
- *Collezioni-Brani:* "PopolateDa"
  - Ogni collezione è popolata da zero o più brani, ogni brano popola zero o più collezioni.
  - Molteplicità N : N
  - Parziale verso *Collezioni*, parziale verso *Brani*.
** Schema E/R
#+CAPTION: Schema entity-relationship
#+ATTR_LATEX: :width 19cm :float nil
[[~/Basi/progetto2015/grooveclam/relazione/img/concettuale.png]]
* Progettazione Logica
** Gerarchie
Tutte le gerarchie presenti nella progettazione concettuale sono state risolte mediante accorpamento in tabella unica, questo perchè
nessuna di esse possedeva sottoclassi con un numero significativo di attributi o associazioni entranti da giustificarne un partizionamento
di qualche genere.
** Chiavi Primarie
Sono state create alcune chiavi primarie per identificare le istanze di alcune tabelle, quali /IdPlaylist/ a *Playlist*. 
** Associazioni
- *Utenti-Login:* "Possiede"
  - Ogni utente possiede una login, ogni login e' posseduta da un utente.
  - Molteplicità 1 : 1
  - Totale verso *Utenti*, totale verso *Login*.
  - Chiave esterna non-nulla in *Login* verso *Utenti*.
- *Utenti-Collezioni:* "Crea"
  - Ogni utente può creare zero o una collezione, ogni collezione può essere creata da un solo utente.
  - Molteplicità 1 : 1
  - Parziale verso *Utenti*, totale verso *Collezioni*.
  - Chiave esterna non-nulla in *Collezioni* verso *Utenti*.
- *Utenti-Brani:* "Ascolta"
  - Ogni utente può ascoltare zero o più brani, ogni brano può essere ascoltato da zero o più utenti.
  - Molteplicità N : N
  - Parziale verso *Utenti*, parziale verso *Brani*.
  - Attributi:
    - Timestamp: /Timestamp/
  - Nuova tabella *Ascoltate*, attributi:
    - IdUtente: /Int/ =<<PK>> <<FK(Utenti)>>=
    - IdBrano: /Int/ =<<PK>> <<FK(Brani)>>=
    - Timestamp: /Timestamp/ =<<PK>>=
- *Utenti-Brani:* "Accoda"
  - Ogni utente può accodare zero o più brani, ogni brano può essere accodato da zero o più utenti.
  - Molteplicità N : N
  - Parziale verso *Utenti*, parziale verso *Brani*.
  - Attributi:
    - Timestamp: /Timestamp/
  - Nuova tabella *Code*, attributi:
    - IdUtente: /Int/ =<<PK>> <<FK(Utenti)>>=
    - IdBrano: /Int/ =<<PK>> <<FK(Brani)>>=
    - Timestamp: /Timestamp/ =<<PK>>=
- *Utenti-Utenti:* "Segue"
  - Ogni utente può seguire zero o più utenti, ogni utente può essere seguito da zero o più utenti.
  - Molteplicità N : N
  - Parziale verso entrambi.
  - Nuova tabella *Seguaci*, attributi:
    - IdUtente: /Int/ =<<PK>> <<FK(Utenti)>>=
    - IdSeguace: /Int/ =<<PK>> <<FK(Utenti)>>=
- *Utenti-Playlist*: "Crea"
  - Ogni utente può creare zero o più playlist, ogni playlist può essere creata da un solo utente.
  - Molteplicità N : 1
  - Parziale verso *Utenti*, totale verso *Playlist*.
  - Chiave esterna non-nulla in *Playlist* verso *Utenti*.
- *Utenti-Iscrizioni:* "Iscritto"
  - Ogni utente può avere una sola iscrizione, ogni iscrizione può essere associata ad un solo utente.
  - Molteplicità 1 : 1
  - Totale verso *Utenti* e verso *Iscrizioni*.
  - Chiave esterna non-nulla in *Iscrizioni* verso *Utenti*.
- *Playlist-Brani:* "PopolataDa"
  - Ogni playlist è popolata da zero o più brani, ogni brano popola zero o più playlist.
  - Molteplicità N : N
  - Parziale verso *Playlist*, parziale verso *Brani*.
  - Nuova tabella *BraniPlaylist*, attributi:
    - IdPlaylist: /Int/ =<<PK>> <<FK(Playlist)>>=
    - IdBrano: /Int/ =<<PK>> <<FK(Brani)>>=
- *Brani-Album:* "AppartieneA"
  - Ogni brano appartiene a zero o un brano, ogni brano contiene uno o più brani.
  - Molteplicità 1 : N
  - Parziale verso *Brani*, totale verso *Album*.
  - Chiave esterna non-nulla in *Brani* verso *Album*.
- *Collezioni-Brani:* "PopolateDa"
  - Ogni collezione è popolata da zero o più brani, ogni brano popola zero o più collezioni.
  - Molteplicità N : N
  - Parziale verso *Collezioni*, parziale verso *Brani*.
  - Nuova tabella *BraniCollezione*, attributi:
    - IdBrano: /int/ =<<PK>> <<FK(Brani)>>=
    - IdCollezione: /int/ =<<PK <<FK(Collezioni)>>=
* Implementazione Fisica
Query di implementazione DDL SQL della base di dati. Sorgente in ~grooveclam.sql~, popolamento in ~populate.sql~.
E' stata implementata una tabella *Errori*, riempita mediante procedura a sua volta richiamata dai trigger che ne fanno uso, 
contiene i messaggi d'errore rilevati.
~functions.sql~ contiene invece le funzioni, i trigger e le procedure implementate.\\
#+BEGIN_LaTeX
\begin{lstlisting}[language=SQL]
SET FOREIGN_KEY_CHECKS = 0;

DROP TABLE IF EXISTS `Errori`;
DROP TABLE IF EXISTS `Album`;
DROP TABLE IF EXISTS `Brani`;
DROP TABLE IF EXISTS `Utenti`;
DROP TABLE IF EXISTS `Seguaci`;
DROP TABLE IF EXISTS `Iscrizioni`;
DROP TABLE IF EXISTS `Collezioni`;
DROP TABLE IF EXISTS `BraniCollezione`;
DROP TABLE IF EXISTS `Playlist`;
DROP TABLE IF EXISTS `BraniPlaylist`;
DROP TABLE IF EXISTS `Code`;
DROP TABLE IF EXISTS `Ascoltate`;
DROP TABLE IF EXISTS `Login`;

-- Table di supporto Errori
CREATE TABLE IF NOT EXISTS `Errori` (
    `Errore` VARCHAR(256) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=Latin1;
-- Table Album
CREATE TABLE IF NOT EXISTS `Album` (
	`IdAlbum` INT(11) NOT NULL AUTO_INCREMENT,
	`Titolo` VARCHAR(200) NOT NULL,
	`Autore` VARCHAR(200) NOT NULL,
	`Info` VARCHAR(300) DEFAULT NULL,
	`Anno` YEAR DEFAULT NULL,
	`Live` BOOLEAN DEFAULT FALSE,
	`Locazione` VARCHAR(100) DEFAULT NULL,
    `PathCopertina` VARCHAR(100) NOT NULL DEFAULT "img/covers/nocover.jpg",
	PRIMARY KEY(`IdAlbum`)
) ENGINE=InnoDB DEFAULT CHARSET=latin1;
-- Table Brani
CREATE TABLE IF NOT EXISTS `Brani` (
	`IdBrano` INT(11) NOT NULL AUTO_INCREMENT,
	`IdAlbum` INT(11) NOT NULL,
	`Titolo` VARCHAR(200) NOT NULL,
	`Genere` VARCHAR(40) NOT NULL,
	`Durata` INT(11),
	PRIMARY KEY(`IdBrano`),
	FOREIGN KEY(`IdAlbum`) REFERENCES Album(`IdAlbum`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=latin1;
-- Table Utenti
CREATE TABLE IF NOT EXISTS `Utenti` (
	`IdUtente` INT(11) NOT NULL AUTO_INCREMENT,
	`Nome` VARCHAR(40) DEFAULT NULL,
	`Cognome` VARCHAR(40) DEFAULT NULL,
	`Email` VARCHAR(40) NOT NULL,
	PRIMARY KEY(`IdUtente`)
) ENGINE=InnoDB DEFAULT CHARSET=latin1;
-- Table Login
CREATE TABLE IF NOT EXISTS `Login` (
    `Username` VARCHAR(40) NOT NULL,
	`Password` VARCHAR(40) NOT NULL,
    `IdUtente` INT(11) NOT NULL,
    PRIMARY KEY(`Username`),
    FOREIGN KEY(`IdUtente`) REFERENCES Utenti(`IdUtente`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=latin1;
-- Table Seguaci
CREATE TABLE IF NOT EXISTS `Seguaci` (
	`IdUtente` INT(11) NOT NULL,
	`IdSeguace` INT(11) NOT NULL,
	CONSTRAINT PRIMARY KEY pk(`IdUtente`, `IdSeguace`),
	FOREIGN KEY(`IdUtente`) REFERENCES Utenti(`IdUtente`) ON DELETE CASCADE ON UPDATE CASCADE,
	FOREIGN KEY(`IdSeguace`) REFERENCES Utenti(`IdUtente`) ON DELETE CASCADE ON UPDATE CASCADE,
	CHECK(`IdUtente` != `IdSeguace`)
) ENGINE=InnoDB DEFAULT CHARSET=latin1;
-- Table Iscrizioni
CREATE TABLE IF NOT EXISTS `Iscrizioni` (
	`IdUtente` INT(10) NOT NULL,
	`Tipo` ENUM('Free', 'Premium') NOT NULL,
	PRIMARY KEY(`IdUtente`),
	FOREIGN KEY(`IdUtente`) REFERENCES Utenti(`IdUtente`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=latin1;
-- Table Collezioni
CREATE TABLE IF NOT EXISTS `Collezioni` (
	`IdCollezione` INT(11) NOT NULL AUTO_INCREMENT,
	`IdUtente` INT(11) NOT NULL,
	PRIMARY KEY(`IdCollezione`),
	FOREIGN KEY(`IdUtente`) REFERENCES Utenti(`IdUtente`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=latin1;
-- Table BraniCollezione
CREATE TABLE IF NOT EXISTS `BraniCollezione` (
	`IdBrano` INT(11) NOT NULL,
	`IdCollezione` INT(11) NOT NULL,
	CONSTRAINT PRIMARY KEY pk(`IdCollezione`, `IdBrano`),
	FOREIGN KEY(`IdBrano`) REFERENCES Brani(`IdBrano`) ON DELETE CASCADE ON UPDATE CASCADE,
	FOREIGN KEY(`IdCollezione`) REFERENCES Collezioni(`IdCollezione`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=latin1;
-- Table Playlist
CREATE TABLE IF NOT EXISTS `Playlist` (
	`IdPlaylist` INT(11) NOT NULL AUTO_INCREMENT,
	`IdUtente` INT(11) NOT NULL,
	`Nome` VARCHAR(40) NOT NULL,
    `Privata` BOOLEAN DEFAULT FALSE,
	PRIMARY KEY(`IdPlaylist`),
	FOREIGN KEY(`IdUtente`) REFERENCES Utenti(`IdUtente`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=latin1;
-- Table BraniPlaylist
CREATE TABLE IF NOT EXISTS `BraniPlaylist` (
	`IdPlaylist` INT(11) NOT NULL,
	`IdBrano` INT(11) NOT NULL,
    `Posizione` INT(11) NOT NULL,
	CONSTRAINT PRIMARY KEY pk(`IdPlaylist`, `IdBrano`),
	FOREIGN KEY(`IdPlaylist`) REFERENCES Playlist(`IdPlaylist`) ON DELETE CASCADE ON UPDATE CASCADE,
	FOREIGN KEY(`IdBrano`) REFERENCES Brani(`IdBrano`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=latin1;
-- Table Code
CREATE TABLE IF NOT EXISTS `Code` (
	`IdUtente` INT(11) NOT NULL,
	`IdBrano` INT(11) NOT NULL,
    `Posizione` INT(11) NOT NULL,
	CONSTRAINT PRIMARY KEY pk(`IdUtente`, `IdBrano`, `Posizione`),
	FOREIGN KEY(`IdUtente`) REFERENCES Utenti(`IdUtente`) ON DELETE CASCADE ON UPDATE CASCADE,
	FOREIGN KEY(`IdBrano`) REFERENCES Brani(`IdBrano`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=latin1;
-- Table Ascoltate
CREATE TABLE IF NOT EXISTS `Ascoltate` (
	`IdUtente` INT(11) NOT NULL,
	`IdBrano` INT(11) NOT NULL,
	`Timestamp` TIMESTAMP NOT NULL,
	CONSTRAINT PRIMARY KEY pk(`IdUtente`, `IdBrano`, `Timestamp`),
	FOREIGN KEY(`IdUtente`) REFERENCES Utenti(`IdUtente`) ON DELETE CASCADE ON UPDATE CASCADE,
	FOREIGN KEY(`IdBrano`) REFERENCES Brani(`IdBrano`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=latin1;
-- Insert into Utente
INSERT INTO Utenti(`Nome`, `Cognome`, `Email`)
       VALUES('Andrea', 'Baldan', 'a.g.baldan@gmail.com'),
	         ('Federico', 'Angi', 'angiracing@gmail.com'),
	         ('Marco', 'Rossi', 'rossi@gmail.com'),
             ('Luca', 'Verdi', 'verdi@yahoo.it'),
             ('Alessia', 'Neri', 'neri@gmail.com');
INSERT INTO Login(`Username`, `Password`, `IdUtente`)
       VALUES('codep', MD5('ciao'), 1),
             ('keepcalm', MD5('calm'), 2),
             ('rossi', MD5('marco'), 3),
             ('verdi', MD5('luca'), 4),
             ('neri', MD5('Alessia'), 5);
-- Insert into Subscrition
INSERT INTO Iscrizioni(`IdUtente`, `Tipo`) VALUES(1, 'Free'), (2, 'Free');
-- Insert into Album
INSERT INTO Album(`Titolo`, `Autore`, `Info`, `Anno`, `Live`, `Locazione`, `PathCopertina`)
       VALUES('Inception Suite', 'Hans Zimmer', 'Inception movie soundtrack, composed by the Great Compositor Hans Zimmer', '2010', 0, NULL, 'img/covers/inception.png'),
             ('The Good, the Bad and the Ugly: Original Motion Picture Soundtrack', 'Ennio Morricone', 'Homonym movie soundtrack, created by the Legendary composer The Master Ennio Morricone', '1966', 0, NULL, 'img/covers/morricone.jpg'),
             ('Hollywood in Vienna 2014', 'Randy Newman - David Newman', 'Annual cinematographic review hosted in Vienna', '2014', 1, 'Vienna', 'img/covers/hivlogo.jpg'),
             ('The Fragile', 'Nine Inch Nails', 'The Fragile is the third album and a double album by American industrial rock band Nine Inch Nails, released on September 21, 1999, by Interscope Records.', '1999', 0, NULL, 'img/covers/fragile.jpg'),
             ('American IV: The Man Comes Around', 'Johnny Cash', 'American IV: The Man Comes Around is the fourth album in the American series by Johnny Cash(and his 87th overall), released in 2002. The majority of songs are covers which Cash performs in his own spare style, with help from producer Rick Rubin.', '2002', 0, NULL, 'img/covers/nocover.jpg'),
             ('Greatest Hits', 'Neil Young', 'Rock & Folk Rock greatest success songs by Neil Young', '2004', 0, NULL, 'img/covers/nocover.jpg');
-- Insert into Brani
INSERT INTO Brani(`IdAlbum`, `Titolo`, `Genere`, `Durata`)
       VALUES(1, 'Mind Heist', 'Orchestra', 203),
             (1, 'Dream is collapsing', 'Orchestra', 281),
             (1, 'Time', 'Orchestra', 215),
             (1, 'Half Remembered Dream', 'Orchestra', 71),
             (1, 'We Built Our Own World', 'Orchestra', 115),
             (1, 'Radical Notion', 'Orchestra', 222),
             (1, 'Paradox', 'Orchestra', 205),
             (2, 'Il Tramonto', 'Orchestra', 72),
             (2, 'L\'estasi dell\'oro', 'Orchestra', 202),
             (2, 'Morte di un soldato', 'Orchestra', 185),
             (2, 'Il Triello', 'Orchestra', 434),
             (3, 'The Simpsons', 'Orchestra', 172),
             (3, 'The war of the Roses', 'Orchestra', 272),
             (4, 'Somewhat Damaged', 'Industrial Metal', 271),
             (4, 'The Day The Whole World Went Away', 'Industrial Metal', 273),
             (4, 'We\'re In This Together', 'Industrial Metal', 436),
             (4, 'Just Like You Imagined', 'Industrial Metal', 229),
             (4, 'The Great Below', 'Industrial Metal', 317),
             (5, 'Hurt', 'Country', 218),
             (5, 'Danny Boy', 'Country', 199),
             (6, 'Old Man', 'Rock', 203),
             (6, 'Southern Man', 'Rock', 331);
-- Insert into BraniCollezione
INSERT INTO BraniCollezione(`IdBrano`, `IdCollezione`) VALUES(1, 1), (2, 1), (3, 1), (7, 1), (14, 1), (12, 1), (17, 1), (18, 1), (2, 2);
-- Insert into Playlist
INSERT INTO Playlist(`IdUtente`, `Nome`, `Privata`) VALUES(1, 'Score & Soundtracks', 0), (1, 'Southern Rock', 0), (2, 'Colonne sonore western', 0);
-- Insert into BraniPlaylist
INSERT INTO BraniPlaylist(`IdPlaylist`, `IdBrano`, `Posizione`) VALUES(1, 1, 1), (1, 2, 2), (1, 3, 3), (1, 4, 4), (1, 5, 5), (2, 21, 1), (2, 22, 2), (3, 5, 1), (3, 7, 2), (3, 4, 3);
-- Insert into Code
INSERT INTO Code(`IdUtente`, `IdBrano`, `Posizione`)
       VALUES(1, 1, 1),
             (1, 5, 2),
             (1, 1, 3),
             (1, 12, 4),
             (1, 10, 5),
             (2, 1, 1);
-- Insert into Ascoltate
INSERT INTO Ascoltate(`IdUtente`, `IdBrano`, `Timestamp`)
       VALUES(1, 1, '2015-04-28 18:50:03'),
             (1, 5, '2015-04-28 18:54:06'),
             (1, 1, '2015-04-28 19:01:43'),
             (3, 7, '2015-04-29 18:51:02'),
             (3, 11, '2015-04-29 17:23:15'),
             (2, 9, '2015-04-30 21:12:52'),
             (2, 1, '2015-05-02 22:21:22');
-- Insert into Seguaci
INSERT INTO Seguaci(`IdUtente`, `IdSeguace`) VALUES(1, 2), (1, 3), (2, 1), (3, 1);
SET FOREIGN_KEY_CHECKS = 1;
\end{lstlisting}
#+END_LaTeX
** Trigger
Di seguito i trigger creati. Sono trigger tipicamente di controllo.
- ~checkDuration:~ Trigger di controllo sull'inserimento della durata obbligatoriamente positiva di un brano, simula il comportamento di una clausola ~CHECK Durata > 0~.
- ~checkFollower:~ Trigger di controllo sull'inserimento di nuovi seguaci, dove un utente non puo inserire il proprio id come seguace, simula il comportamento di una clauso ~CHECK IdUtente <> IdSeguace~.
- ~checkCoverImage:~ Trigger di controllo sull'inserimento di una nuova Copertina, se il valore del path e' vuoto, viene inserito il path standard '~img/covers/nocover.jpg~'.
- ~insertAutoCollection:~ Trigger di controllo sull'inserimento di un nuovo utente, si occupa di generare una collezione vuota per il nuovo utente inserito, creando un entry nella tabella ~Collezioni~.
- ~errorTrigger:~ Trigger di supporto, utilizzato per simulare un sistema di segnalazione errori, esegue un ~SET NEW = NEW.errore;~ che genera un messaggio in quanto ~NEW~ non puo essere manipolato e visualizza il messaggio passato alla procedura ~RAISE_ERROR~.
#+BEGIN_LaTeX
\begin{lstlisting}[language=SQL]
DROP TRIGGER IF EXISTS checkDuration;
DROP TRIGGER IF EXISTS errorTrigger;
DROP TRIGGER IF EXISTS checkFollower;
DROP TRIGGER IF EXISTS checkCoverImage;
DROP TRIGGER IF EXISTS insertAutoCollection;

DELIMITER $$

CREATE TRIGGER checkDuration
BEFORE INSERT ON `Brani`
FOR EACH ROW
BEGIN
IF(NEW.Durata < 0) THEN
    CALL RAISE_ERROR('La durata di un brano non può essere negativa');
END IF;
END $$

CREATE TRIGGER errorTrigger
BEFORE INSERT ON `Errori`
FOR EACH ROW
BEGIN
    SET NEW = NEW.errore;
END $$

DELIMITER ;

DELIMITER $$

CREATE TRIGGER checkFollower
BEFORE INSERT ON `Seguaci`
FOR EACH ROW
BEGIN
    IF NEW.IdUtente = NEW.IdSeguace THEN
       CALL RAISE_ERROR('Un utente non può seguire se stesso (IdUtente e IdSeguace devono essere diversi fra loro)');
    END IF;       
END $$
DELIMITER ;

DELIMITER $$

CREATE TRIGGER checkCoverImage
BEFORE INSERT ON `Copertine`
FOR EACH ROW
BEGIN
    IF NEW.Path = '' THEN
       SET NEW.Path = 'img/covers/nocover.jpg';
    END IF;
END $$

DELIMITER ;
\end{lstlisting}
#+END_LaTeX
** Funzioni e Procedure
Alcune funzioni e procedure implementate. Si tratta di funzioni e procedure di utilita' generale.
*** Funzioni
- ~albumTotalDuration:~ Dato un Id intero che rappresenta la chiave primaria di un album all'interno della base di dati, calcola la durata totale dell'album sommando le singole durate di ogni brano appartenente a tale album, convertendo il risultato finale in minuti. Utilizzando la funzione ~CONCAT~ restituisce una stringa formattata mm:ss.
- ~elegibleForPrize:~ Dato un id intero ~IdUser~ che rappresenta la chiave primaria di un utente all'interno della base di dati e una stringa che rappresenta un genere musicale, calcola la durata totale di ascolto su quel genere musicale da parte dell'utente rappresentato da ~IdUser~. Restituisce un booleano, true nel caso in cui l'ascolto totale in secondi sia >= 1000, false altrimenti.
#+BEGIN_LaTeX
\begin{lstlisting}[language=SQL]
DROP FUNCTION IF EXISTS albumTotalDuration;
DROP FUNCTION IF EXISTS elegibleForPrize;

DELIMITER $$

CREATE FUNCTION albumTotalDuration(IdAlbum INT)
RETURNS VARCHAR(5)
BEGIN
DECLARE Seconds INT UNSIGNED;
SELECT SUM(b.Durata) INTO Seconds FROM Brani b WHERE b.IdAlbum = IdAlbum;
RETURN CONCAT(FLOOR(Seconds / 60), ':', (Seconds % 60));
END $$

DELIMITER ;

DELIMITER $$

CREATE FUNCTION elegibleForPrize(IdUser INT, Genre VARCHAR(50))
RETURNS BOOLEAN
BEGIN
DECLARE Seconds INT UNSIGNED DEFAULT 0;
DECLARE Elegibility BOOLEAN DEFAULT FALSE;
SELECT SUM(b.Durata) INTO Seconds
FROM Ascoltate a INNER JOIN Utenti u ON(a.IdUtente = u.IdUtente)
                 INNER JOIN Brani b ON(a.IdBrano = b.IdBrano)
WHERE b.Genere = 'Orchestra' AND a.IdUtente = IdUser;
IF(Seconds >= 1000) THEN
           SET Elegibility = TRUE;
END IF;
RETURN Elegibility;
END $$

DELIMITER ;
\end{lstlisting}
#+END_LaTeX
*** Procedure
- ~GENRE_DISTRIBUTION:~ Calcola la distribuzione dei generi di brani presenti all'interno della base di dati restituendo le percentuali di presenza dei vari generi. Per farlo crea una ~temporary table~ e la popola con le percentuali calcolate contando il totale delle canzoni e i parziali riferiti ad ogni genere, e formatta il risultato in % grazie all'utilizzo della funzione ~CONCAT~.
- ~USER_GENRE_DURATION:~ Riprende il concetto di ~GENRE_DISTRIBUTION~ ma lo applica ad un utente identificato dall'Id intero passato in input, utilizzando un cursore, inserisce in una ~temporary table~ il numero di brani raggruppati per genere e ne calcola la percentuale sul totale di brani presenti all'interno della collezione dell'utente.
- ~SWAP_POSITION:~ Procedura di utilita', utilizzata in alcune pagine dell'interfaccia web, permette di scambiare i valori di due colonne (anche ~unique~ o ~primary key~) all'interno delle tabelle ~Code~ o ~Playlist~, lo scopo e' la possibilita di modificare l'ordine dei brani all'interno delle ~code~ o delle ~playlist~.
- ~RAISE_ERROR:~ Procedura di supporto utilizzata in congiunta con il trigger ~errorTrigger~ e la tabella ~Errori~  per simulare messaggi d'errore, inserisce la stringa passata come parametro in ingresso all'interno della tabella ~Errori~, il trigger si occupera' di sollevare il messaggio.
#+BEGIN_LaTeX
\begin{lstlisting}[language=SQL]
DROP PROCEDURE IF EXISTS RAISE_ERROR;
DROP PROCEDURE IF EXISTS GENRE_DISTRIBUTION;
DROP PROCEDURE IF EXISTS USER_GENRE_DISTRIBUTION;
DROP PROCEDURE IF EXISTS SWAP_POSITION;

DELIMITER $$

CREATE PROCEDURE RAISE_ERROR (IN ERROR VARCHAR(256))
BEGIN
DECLARE V_ERROR VARCHAR(256);
SET V_ERROR := CONCAT('[ERROR: ', ERROR, ']');
INSERT INTO Errors VALUES(V_ERROR);
END $$

DELIMITER ;

DELIMITER $$

CREATE PROCEDURE GENRE_DISTRIBUTION()
BEGIN
DECLARE Total INT DEFAULT 0;
DROP TEMPORARY TABLE IF EXISTS `Distribution`;
CREATE TEMPORARY TABLE `Distribution` (
       `Genere` VARCHAR(100),
       `Percentuale` VARCHAR(6)
) ENGINE=InnoDB;
SELECT count(b.Genere) INTO Total FROM Brani b;
INSERT INTO Distribution (Genere, Percentuale)
SELECT Genere, CONCAT(FLOOR((count(Genere) / Total) * 100), "%")
FROM Brani GROUP BY Genere;
END $$

DELIMITER ;

DELIMITER $$

CREATE PROCEDURE USER_GENRE_DISTRIBUTION(IN IdUser INT)
BEGIN
DECLARE Done INT DEFAULT 0;
DECLARE Total INT DEFAULT 0;
DECLARE Genre VARCHAR(100) DEFAULT "";
DECLARE Counter INT DEFAULT 0;
DECLARE D_CURSOR CURSOR FOR
        SELECT b.Genere, COUNT(b.IdBrano)
        FROM Brani b INNER JOIN BraniCollezione bc ON (b.IdBrano = bc.IdBrano)
                     INNER JOIN Collezioni c ON(c.IdCollezione = bc.IdCollezione)
        WHERE c.IdUtente = IdUser
        GROUP BY b.Genere, c.IdUtente;
DECLARE CONTINUE HANDLER
FOR NOT FOUND SET Done = 1;
SELECT COUNT(b.IdBrano) INTO Total
FROM Brani b INNER JOIN BraniCollezione bc ON(b.IdBrano = bc.IdBrano)
             INNER JOIN Collezioni c ON(bc.IdCollezione = c.IdCollezione)
WHERE c.IdUtente = IdUser;
DROP TEMPORARY TABLE IF EXISTS `Distribution`;
CREATE TEMPORARY TABLE `Distribution` (
       `Genere` VARCHAR(100),
       `Percentuale` VARCHAR(6)
) ENGINE=InnoDB;
OPEN D_CURSOR;
REPEAT
        FETCH D_CURSOR INTO Genre, Counter;
        IF NOT Done THEN
           INSERT INTO Distribution (Genere, Percentuale)
           VALUES(Genre, CONCAT(FLOOR((Counter / Total) * 100), "%"));
        END IF;
UNTIL Done END REPEAT;
CLOSE D_CURSOR;
SELECT * FROM `Distribution` ORDER BY Percentuale DESC;
DROP TABLE `Distribution`;      
END $$

DELIMITER ;

DELIMITER $$

CREATE PROCEDURE SWAP_POSITION(IN a INT, IN b INT, IN id INT, IN tab INT)
BEGIN
DECLARE AUX INT DEFAULT -1;
CASE tab
     WHEN 1 THEN
          UPDATE Code SET Posizione = AUX WHERE Posizione = a AND IdUtente = id;
          UPDATE Code SET Posizione = a WHERE Posizione = b AND IdUtente = id;
          UPDATE Code SET Posizione = b WHERE Posizione = AUX AND IdUtente = id;
     ELSE        
          UPDATE BraniPlaylist SET Posizione = AUX WHERE Posizione = a AND IdPlaylist = id;
          UPDATE BraniPlaylist SET Posizione = a WHERE Posizione = b AND IdPlaylist = id;
          UPDATE BraniPlaylist SET Posizione = b WHERE Posizione = AUX AND IdPlaylist = id;
END CASE;
END $$

DELIMITER ;
\end{lstlisting}
#+END_LaTeX
* Query
Alcune query significative.
1. Titolo, album e username dell'utente, degli ultimi 10 brani ascoltati tra i followers.
   #+BEGIN_LaTeX
  \begin{lstlisting}[language=SQL]
  SELECT b.Titolo, a.Titolo as TitoloAlbum, u.Username, DATE_FORMAT(h.Timestamp, '%d-%m-%Y %T') AS Data
  FROM Brani b INNER JOIN Album a ON(b.IdAlbum = a.IdAlbum)
			   INNER JOIN Ascoltate h ON(h.IdBrano = b.IdBrano)
			   INNER JOIN Seguaci f ON(f.IdSeguace = h.IdUtente)
               INNER JOIN Utenti u ON(u.IdUtente = f.IdSeguace)
  WHERE h.Timestamp BETWEEN DATE_SUB(CURDATE(), INTERVAL 7 DAY) AND CURDATE()
  AND u.IdUtente IN (SELECT u.IdUtente
                     FROM Utenti u INNER JOIN Seguaci f ON(f.IdSeguace = u.IdUtente) 
                     WHERE f.IdUtente = 1)
  ORDER BY h.Timestamp DESC LIMIT 10;
  \end{lstlisting}
   \begin{verbatim}
   Output:
+-----------------------------------+-----------------+----------+---------------------+
| Titolo                            | TitoloAlbum     | Username | Data                |
+-----------------------------------+-----------------+----------+---------------------+
| The Day The Whole World Went Away | The Fragile     | keepcalm | 26-05-2015 15:04:37 |
| Paradox                           | Inception Suite | keepcalm | 26-05-2015 15:04:36 |
+-----------------------------------+-----------------+----------+---------------------+
2 rows in set (0.00 sec)
   \end{verbatim}
  #+END_LaTeX
2. Username e numero di volte che è stata ascoltata la canzone Paradox dai follower dell'user id 1
   #+BEGIN_LaTeX
  \begin{lstlisting}[language=SQL]
  SELECT COUNT(b.IdBrano) AS Conto, u.Username 
  FROM Brani b INNER JOIN Ascoltate h ON(b.IdBrano = h.IdBrano) 
               INNER JOIN Seguaci f ON(h.IdUtente = f.IdSeguace)
               INNER JOIN Utenti u ON(f.IdSeguace = u.IdUtente) 
  WHERE b.Titolo = 'Paradox' AND f.IdUtente = 1 GROUP BY u.Username ORDER BY Conto DESC;
  \end{lstlisting}
   \begin{verbatim}
   Output:
+-------+----------+
| Conto | Username |
+-------+----------+
|     1 | keepcalm |
|     1 | rossi    |
+-------+----------+
2 rows in set (0.00 sec)
   \end{verbatim}
  #+END_LaTeX
3. Username, titolo e conto delle canzoni piu ascoltate dai follower dell'user id 1
   #+BEGIN_LaTeX
  \begin{lstlisting}[language=SQL]
  SELECT u.Username, b.Titolo, COUNT(b.IdBrano) AS Conto 
  FROM Brani b INNER JOIN Ascoltate h ON(b.IdBrano = h.IdBrano) 
               INNER JOIN Seguaci f ON(h.IdUtente = f.IdSeguace)
               INNER JOIN Utenti u ON(f.IdSeguace = u.IdUtente) 
  WHERE f.IdUtente = 1 GROUP BY b.Titolo ORDER BY Conto DESC;
  \end{lstlisting}
   \begin{verbatim}
   Output:
+----------+-----------------------------------+-------+
| Username | Titolo                            | Conto |
+----------+-----------------------------------+-------+
| keepcalm | Paradox                           |     2 |
| keepcalm | We Built Our Own World            |     1 |
| keepcalm | The Day The Whole World Went Away |     1 |
| keepcalm | Mind Heist                        |     1 |
| keepcalm | The Simpsons                      |     1 |
| keepcalm | L'estasi dell'oro                 |     1 |
| rossi    | Il Triello                        |     1 |
+----------+-----------------------------------+-------+
7 rows in set (0.00 sec)
\end{verbatim}
  #+END_LaTeX
4. Username e numero brani nella collezione dell'utente con più canzoni di genere 'Orchestra'
   #+BEGIN_LaTeX
  \begin{lstlisting}[language=SQL]
  DROP VIEW IF EXISTS ContoBrani;
  CREATE VIEW ContoBrani AS
  SELECT u.Username, COUNT(b.Genere) as Conteggio
  FROM Brani b INNER JOIN BraniCollezione bc ON(b.IdBrano = bc.IdBrano)
               INNER JOIN Collezioni c ON(bc.IdCollezione = c.IdCollezione)
               INNER JOIN Utenti u ON(c.IdUtente = u.IdUtente)
  WHERE b.Genere = 'Orchestra' GROUP BY c.IdUtente;
  SELECT * FROM ContoBrani HAVING MAX(Conteggio);
  DROP VIEW IF EXISTS ContoBrani;
  \end{lstlisting}
   \begin{verbatim}
   Output:
+----------+-----------+
| Username | Conteggio |
+----------+-----------+
| codep    |         6 |
+----------+-----------+
1 row in set (0.00 sec)
   \end{verbatim}
  #+END_LaTeX
5. Username e minuti di ascolto dei 3 utenti che ascolta più musica di genere 'Orchestra'
  #+BEGIN_LaTeX
  \begin{lstlisting}[language=SQL]
  DROP VIEW IF EXISTS UtentiGenere;
  CREATE VIEW UtentiGenere AS
  SELECT u.Username, b.Genere, CONCAT(FLOOR(SUM(b.Durata) / 60), ":", (SUM(b.Durata) % 60)) AS DurataTotale
  FROM Ascoltate a INNER JOIN Utenti u ON(a.IdUtente = u.IdUtente)
                   INNER JOIN Brani b ON(a.IdBrano = b.IdBrano)
  WHERE b.Genere = 'Orchestra' GROUP BY a.IdUtente ORDER BY DurataTotale DESC;
  SELECT * FROM UtentiGenere LIMIT 3;
  DROP VIEW IF EXISTS UtentiGenere;
  \end{lstlisting}
  \begin{verbatim}
   Output:
Query OK, 0 rows affected, 1 warning (0.00 sec)

Query OK, 0 rows affected (0.01 sec)

+----------+-----------+--------------+
| Username | Genere    | DurataTotale |
+----------+-----------+--------------+
| verdi    | Orchestra | 29:13        |
| codep    | Orchestra | 20:42        |
| keepcalm | Orchestra | 14:57        |
+----------+-----------+--------------+
3 rows in set (0.03 sec)

Query OK, 0 rows affected (0.02 sec)

Query OK, 0 rows affected (0.00 sec)
  \end{verbatim} 
    #+END_LaTeX
6. Trova gli utenti che hanno ascoltato un numero di canzoni sopra alla media nell'ultimo mese
  #+BEGIN_LaTeX
 \begin{lstlisting}[language=SQL]
 DROP VIEW IF EXISTS CanzoniAscoltate;
 CREATE VIEW CanzoniAscoltate AS
 SELECT u.Username, COUNT(a.IdBrano) as Conto
 FROM Ascoltate a INNER JOIN Brani b ON(a.IdBrano = b.IdBrano)
                  INNER JOIN Utenti u ON(a.IdUtente = u.IdUtente)
 WHERE a.Timestamp BETWEEN DATE_SUB(CURDATE(), INTERVAL 30 DAY) AND NOW()
 GROUP BY a.IdUtente;
 SELECT ca.* 
 FROM CanzoniUtente ca 
 WHERE ca.Conto > (SELECT AVG(ce.Conto) 
                   FROM CanzoniAscoltate ce)
 ORDER BY ca.Conto DESC;
 DROP VIEW IF EXISTS CanzoniAscoltate;
 \end{lstlisting}
 \begin{verbatim}
  Output:
+----------+-------+
| Username | Conto |
+----------+-------+
| verdi    |    10 |
| codep    |    10 |
+----------+-------+
2 rows in set (0.02 sec)

Query OK, 0 rows affected (0.00 sec)
 \end{verbatim}
 #+END_LaTeX
7. Trova gli utenti e il numero di brani di genere 'Country' nella propria collezione
 #+BEGIN_LaTeX
 \begin{lstlisting}[language=SQL]
 CREATE VIEW Conteggi AS
 SELECT u.Username, b.Genere, COUNT(b.IdBrano) AS Conteggio 
 FROM BraniCollezione c INNER JOIN Brani b ON(c.IdBrano = b.IdBrano) 
                        INNER JOIN Collezioni cn ON(c.IdCollezione = cn.IdCollezione)
                        INNER JOIN Utenti u ON(cn.IdUtente = u.IdUtente)
 GROUP BY b.Genere, c.IdCollezione;
 SELECT Username, Conteggio 
 FROM Conteggi
 WHERE Genere = 'Country' HAVING Conteggio = (SELECT MAX(Conteggio)
                                              FROM Conteggi 
                                              WHERE Genere = 'Country');
 DROP VIEW IF EXISTS Conteggi;
 \end{lstlisting}
 \begin{verbatim}
  Output:
+----------+-----------+
| Username | Conteggio |
+----------+-----------+
| keepcalm |         2 |
+----------+-----------+
1 row in set (0.00 sec)
 \end{verbatim}
 #+END_LaTeX
8. Trova gli utenti con più di 5 brani nella propria collezione che non hanno mai ascoltato brani country nell'ultimo mese
 #+BEGIN_LaTeX
 \begin{lstlisting}[language=SQL]
 SELECT DISTINCT u.Username
 FROM Utenti u INNER JOIN Ascoltate a ON(u.IdUtente = a.IdUtente)
 WHERE u.IdUtente NOT IN (
    SELECT DISTINCT u1.IdUtente 
    FROM Ascoltate a1 INNER JOIN Utenti u1 ON(a1.IdUtente = u1.IdUtente)
                      INNER JOIN Brani b ON(a1.IdBrano = b.IdBrano)
    WHERE b.Genere = 'Country')
 AND a.Timestamp BETWEEN DATE_SUB(CURDATE(), INTERVAL 30 DAY) AND NOW()
 AND u.IdUtente IN (SELECT u2.IdUtente 
                    FROM Utenti u2 INNER JOIN Ascoltate a2 ON(u2.IdUtente = a2.IdUtente)
                    GROUP BY a2.IdUtente 
                    HAVING COUNT(a2.IdBrano) > 5);
 \end{lstlisting}
 \begin{verbatim}
  Output:
+----------+
| Username |
+----------+
| keepcalm |
| verdi    |
+----------+
2 rows in set (0.02 sec)
 \end{verbatim}
   #+END_LaTeX
* Interfaccia Web
Per l'interfaccia web è stato seguito un pattern MVC molto rudimentale, che tuttavia ha permesso di semplificarne la realizzazione modularizzando
le operazione da effettuare sulla base di dati mediante le pagine.
** Organizzazione e Struttura Generale
La struttura generale dell'interfaccia consiste di 3 cartelle principali e 2 pagine di servizio contenenti rispettivamente un singleton dedicato
esclusivamente alla connessione alla base di dati e un singleton dedicato alla creazione e manipolazione delle sessioni.
Le cartelle /models, /views, /controllers seguono le tipiche linee guida del pattern MVC, all'interno di /models troviamo infatti i modelli, 
oggetti atti ad interfacciarsi con la base di dati ed eseguire le query richieste dalle pagine (routes) contenute nei controllers, infine le view, 
pagine "di template" contenenti per lo più codice HTML e brevi tratti di PHP, vengono popolate mediante le chiamate ai controllers.
La navigazione vera e propria tra le pagine avviene mediante parametri GET che si occupano di selezionare il controller richiesto e l'azione da 
eseguire (funzioni all'interno del controller richiesto).
*** Esempi
- Richiedere la pagina albums:
~/basidati/~abaldan/?controller=albums&action=index~
- Visualizzazione brano con id = 4:
~/basidati/~abaldan/?controller=songs&action=show&id=4~
** Pagine Principali
Ci sono 6 pagine principali che consentono la navigazione all'interno dell'interfaccia, accedibili mediante un menù laterale a sinistra.
*Home* contiene alcune statistiche sullo stato della BD, ad esempio i brani ascoltati recentemente dai propri followers, questo solo dopo aver
effettuato l'accesso con un proprio account registrato, altrimenti in home, come pure in ogni pagina che richiede di essere loggati, viene 
mostrato un form di login mediantei il quale è anche possibile registrare un account.
*Songs* è la pagina adibita alla visualizzazione di tutte le canzoni contenute nella BD o, nel caso di account loggato, offre la possibilità di 
aggiungere i propri brani alla BD, aggiungerne alla propria collezione o alla coda di riproduzione; *Albums* contiene tutti gli album presenti nella
piattaforma, sempre previa autenticazione permette di inserirne di nuovi ed è possibile visualizzare i dettagli di ogni album e brano contenuto in
esso. *Collection* e *Playlist* sono rispettivamente le pagine di gestione della propria collezione brani e playlist, con la possibilità di privatizzare
o rendere pubbliche le proprie playlist. *Queue* infine ospita la coda di riproduzione, ordinate in base ai timestamp di aggiunta.
E' possibile modificare i dati relativi al proprio account, incluso il piano di'iscrizione, utilizzando la pagina accessibile clickando sul 
bottone in alto a sinistra *settings*, solo dopo aver loggato.
** Mantenimento Stato Pagine
L'interfaccia da la possibilità di ascoltare canzoni come utente visitatore (anonimo), ma per le operazioni più specifiche, ad esempio la creazione
e gestione di una personale collezione è necessario registrarsi e loggare utilizzando le credenziali scelte, è stato pertanto creato un sistema di
gestione delle sessioni mediante la classe singleton /GrooveSession/, nel file session.php.\\
Essa contiene i campi dati basilari quali l'id della sessione che si va a creare e l'istanza dell'oggetto che la contiene, e i metodi necessari alla 
gestione con la possibilità di aggiungere variabili utili.\\
Alcuni account di prova:
- codep : ciao
- rossi : marco
- verdi : luca
** Note
Trattandosi di un interfaccia "simulativa", in quanto la principale materia d'interesse è la struttura della base di dati su cui poggia, la 
riproduzione effettiva dei brani non è stata implementata, e non esistono fisicamente file Mp3 caricati all'interno della base di dati, è stato
tuttavia implementato un semplice e rudimentale riproduttore in poche righe di javascript atto a dare un'idea dell'effettivo utilizzo che una 
completa implementazione della piattaforma porterebbe ad avere. Non sono stati scritti controlli di alcun tipo sull'input da parte dell'utente.
